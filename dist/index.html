<!doctype html>
<html>
<head>
<title>DEV HalfEdge Mesh</title>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r78/three.js"></script>
<script type="text/javascript" src="exported-ThreeCSG.js"></script>
</head>
<body>
<button id="stepButton">Click Me</button>
<script type="text/javascript" src="HELib.js"></script>
<script>

var WIDTH = window.innerWidth * 0.8;
var HEIGHT = window.innerHeight * 0.8;

var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, WIDTH/HEIGHT, 0.1, 1000 );
camera.position.set(0, 0, 5);
camera.lookAt(new THREE.Vector3());

var controls = new THREE.OrbitControls(camera)

var renderer = new THREE.WebGLRenderer();
renderer.setSize( WIDTH, HEIGHT );
document.body.appendChild( renderer.domElement );

var material = new THREE.MeshBasicMaterial({
    wireframe: true,
    color: 0x00ff00
});
var iterativeMat = new THREE.MeshBasicMaterial({
    color: 0x0000ff
});
var debugMat = new THREE.MeshNormalMaterial();

var interiorColor = new THREE.Color( 0xff0000 );
var frontierColor = new THREE.Color( 0x00ff00 );
var boundaryColor = new THREE.Color( 0x0000ff );

function generate2HoleCube() {
    var geom = new THREE.Geometry(); 

    geom.vertices = [
        new THREE.Vector3(1.000000, -1.000000, -1.000000),
        new THREE.Vector3(1.000000, -1.000000, 1.000000),
        new THREE.Vector3(-1.000000, -1.000000, 1.000000),
        new THREE.Vector3(-1.000000, -1.000000, -1.000000),
        new THREE.Vector3(1.000000, 1.000000, -0.999999),
        new THREE.Vector3(0.999999, 1.000000, 1.000001),
        new THREE.Vector3(-1.000000, 1.000000, 1.000000),
        new THREE.Vector3(-1.000000, 1.000000, -1.000000)
    ];
    geom.faces = [
        new THREE.Face3(1, 4, 5),
        new THREE.Face3(1, 0, 4),
        new THREE.Face3(2, 5, 6),
        new THREE.Face3(2, 1, 5),
        new THREE.Face3(3, 6, 7),
        new THREE.Face3(3, 2, 6),
        new THREE.Face3(7, 0, 3),
        new THREE.Face3(7, 4, 0)
    ];
    return geom;
}


// testHalfEdge( scene );
testCSG( scene );


function testCSG( scene ) {
    //var geometry1 = new THREE.SphereGeometry( 5, 32, 32 );
    //var geometry2 = new THREE.SphereGeometry( 5, 32, 32 );

    var geometry1 = new THREE.BoxGeometry( 2, 2, 2 );
    var geometry2 = new THREE.BoxGeometry( 2, 2, 2 );

    var mesh1 = new THREE.Mesh( geometry1, material );
    var mesh2 = new THREE.Mesh( geometry2, material );
    mesh1.position.set(-0.5,-0.5,-0.5);
    mesh2.position.set( 0.5, 0.5, 0.5);

    var joinedMesh = HELib.CSGLib.combineMeshes(mesh1, mesh2);

    // verify csg result
    var vertCount = joinedMesh.geometry.vertices.length;
    var expectedVerts = 32;
    console.log("Expected result with %s, got %s ", expectedVerts, vertCount);

    scene.add( joinedMesh );
}

function testHalfEdge( scene, iterationMax = 0) {
    // var seedGeom = new THREE.BoxGeometry( 1, 1, 1 );
    // var seedGeom = new THREE.PlaneGeometry( 1, 1, 1 );
    var seedGeom = generate2HoleCube();
    var seedMesh = new THREE.Mesh( seedGeom, material );
    scene.add( seedMesh );


    var iterativeGeo = new THREE.Geometry();
    var heMesh = new HELib.HEMesh({ geometry: seedGeom });
    heMesh.closeHoles();
    heMesh.generateFaceArrows( scene );

    var iterator = heMesh.iterateFrontier();

    var waitForPrompting = false;
    var useFaceFragments = false;
    if (!useFaceFragments) {
        iterativeGeo.vertices = heMesh.vertices.map(function(v) {
            return v.position;
        });
    }

    var expansion;
    var counter = 0;
    var button = document.getElementById('stepButton');
    var iterativeMesh; //  = new THREE.Mesh( iterativeGeo, iterativeMat );
    var iterativeMeshes = [];

    function iterationLimitedStep() {
        if (counter >= iterationMax && iterationMax > 0) {
            return;
        }
        // console.log("on %s of %s", counter, iterationMax);

        expansion = stepIterator(iterator, iterativeGeo, useFaceFragments);

        if (waitForPrompting) {
            iterativeMesh = new THREE.Mesh( iterativeGeo.clone(), iterativeMat );
            iterativeMeshes[counter] = iterativeMesh;
            scene.add( iterativeMeshes[counter] );

            if (expansion.done) {
                counter++;
                button.removeEventListener('click', iterationLimitedStep);
                return;
            }
        }
        counter++;
    }

    iterationLimitedStep();
    if (waitForPrompting) {
        button.addEventListener('click', iterationLimitedStep);
    } else {
        while (!expansion.done) {
            iterationLimitedStep();
        }
    }

    if (!waitForPrompting) {
        iterativeMesh = new THREE.Mesh( iterativeGeo, iterativeMat );
        scene.add( iterativeMesh );
    }
}

function stepIterator(iterator, geometry, duplicateVertices) {
    var expansion = iterator.next();
    // assume this means it just finished since the calling also loop monitors done
    if (expansion.done) { 
        console.log("terminal value: ", expansion.value);
        return expansion;
    }

    expansion.value.newEdges.map(function(newFrontierEdge){
        newFrontierEdge.arrow.setColor( frontierColor );
    });
    expansion.value.closedEdges.map(function(closedEdge){
        if (closedEdge.twin.isBoundary) {
            closedEdge.arrow.setColor( boundaryColor );
        } else {
            closedEdge.arrow.setColor( interiorColor );
        }
    });

    if (duplicateVertices) {
        addSeparateFaceToGeometry(expansion.value.face, geometry);
    } else {
        addFaceToGeometry(expansion.value.face, geometry);
    }

    return expansion;
}

function addSeparateFaceToGeometry(face, geo) {
    var index = geo.vertices.length;
    face.edge.loopEdges(function(edge, initial){
        geo.vertices.push(edge.vert.position.clone());
    });

    var a = index++;
    var b = index++;
    var c = index++;
    geo.faces.push( new THREE.Face3(a,b,c) );
}

function addFaceToGeometry(face, geo) {
    var f = face.edge.loopEdges(function(edge){
        return edge.vert.index;
    });
    geo.faces.push( new THREE.Face3(f[0], f[1], f[2]) );
}

var axisHelper = new THREE.AxisHelper( 5 );
scene.add( axisHelper );

var render = function () {
    requestAnimationFrame( render );
    renderer.render(scene, camera);
};

render();

</script>
</body>
</html>
